通过上一章节实现的与非门、非门、与门、或门、异或门等逻辑门来继续学习二进制的运算

## 1、半加器

输入：两个二进制位 a 和 b
加法元件将两个比特相加。结果是个2位的值。

h输出是高位，l输出是低位（就像在2位10进制数中，十位是高位，个位是低位）。

|   输入a   |   输入b   |   高位   |  低位|
| ---- | ---- | ---- | ---- |
|   0   |   0   |    0  |   0   |
|   0   |   1   |    0  |   1   |
|   1   |   0   |    0  |   1   |
|   1   |   1   |    1  |   0   |

从真值表可以看出：
低位 相当于 a 和 b 的异或（XOR）运算。
高位 相当于 a 和 b 的与（AND）运算。

**半加器的逻辑表达式**
低位 (和) = a XOR b
高位 (进位) = a AND b

**电路**

![image](https://img2024.cnblogs.com/blog/705163/202409/705163-20240914142331068-386007365.png)

## 2、全加器

一个加法元件，有3个输入：a, b, 和c。

输出是一个2位的数值。h是高位=进位、l是低位=和。

|   输入a   |   输入b|   输入c   |   高位   |  低位|
| ---- | ---- | ---- | ---- | ---- |
|   0   |   0   |    0  |   0   |   0   |
|   0   |   0   |    1  |   0   |   1   |
|   0   |   1   |    0  |   0   |   1   |
|   0   |   1   |    1  |   1   |   0   |
|   1   |   0   |    0  |   0   |   1   |
|   1   |   0   |    1  |   1   |   0   |
|   1   |   1   |    0  |   1   |   0   |
|   1   |   1   |    1  |   1   |   1   |


**逻辑表达式**
l= a+b+c
h=(a⋅b)+(b⋅c)+(a⋅c)

**逻辑门电路图：**
1、l 逻辑：
异或门 1：输入 a 和 b，输出 a+b
异或门 2：输入 a+b 和 c，输出 l
2、h 逻辑：
与门1：输入 a 和b，输出 a⋅b
与门2：输入 b 和c，输出 b⋅c
与门3：输入 a 和c，输出 a⋅c
或门1：将与门 1 和与门 2 的输出相加
或门2：将上一步的结果与与门 3 的输出相加，得到 h

**电路**

![image](https://img2024.cnblogs.com/blog/705163/202409/705163-20240919094814635-655268660.png)

## 3、多位加法器

这个例子是二位加法器，但是对于三位，四位加法器逻辑类似，从右往左，先是处理两位输入和进位，算出高位和低位，低位记录起来高位传入到下一个进位，接下来又是处理两位输入和进位，依次类推实现多位加法器。看到这里其实就和十进制加法没什么区别，十进制多位加法也是从右往左算，低位结果保留，进位放到下一步继续计算，以此类推直到算出所有结果。
写到这里突然想到最近在《编码：隐匿在计算机软硬件背后的语言》这本书看到二进制减法的运算，作者一开始不是直接讲减数要转换成补码再计算，而是讲了十进制减法为了不使用借位如何方便计算。比如`61-19`，由于1不够减需要向6借以一位，那么有没有什么办法不借位计算呢？可以利用十进制的补数实现，可以通过`99-19=80，61+80=141，141-100+1=42`，三个式子简化一下就是`61+(99-19)-100+1`，这个式子和`61-19`的结果是一样的，因为+100和-100其实就是0，这样子主要是不用借位，这样子计算对于人类来说太复杂了，毕竟简单的借位对人类来说很简单，为什么要提十进制的补数在减法的应用，因为二进制减法就是用了这个逻辑来实现的，减数为什么要取反？因为二进制的`1111 1111-0001 0011=1110 1100`，这里用八个1去减就相当于十进制的99去减，这样子不用借位同时刚好是减数的反码，0001 0011的反码就是1110 1100，接下来是被减数加上减数的反码，`0011 1101+1110 1100=1 0010 1001`，接着再加一，`1 0010 1001+1=1 0010 1010`，前面加了1111 1111 和1，接下来要减掉，`1 0010 1010-1 000 000 =0010 1010`，取得了二进制的补码。这样子在二进制的计算减法中也没用使用借位。文字和式子放在一起可能不好理解，单独把式子提取出来。

61(0011 1101)-19(0001 0011)补数的减法
十进制：
`99-19=80`
`61+80=141`
`141-100+1=42`
把上面三个合成一个式子：
`61+(99-19)-100+1=42`
二进制：
`1111 1111-0001 0011=1110 1100(惊讶的发现0001 0011对每一位取反就是1110 1100)`
`0011 1101+1110 1100=1 0010 1001`
`1 0010 1001+1=1 0010 1010`
`1 0010 1010-1 000 000 =0010 1010`

二进制的就不合成一个式子了，因为一合成那么多0和1更不好理解，整体来讲就是二进制的减法就是用了补数的逻辑实现的，这下就理解了二进制减数为什么要取反以及为什么要再加一，经过这两个操作被减数加减数得出的是原本两个数相减的结果。

**电路**

![image](https://img2024.cnblogs.com/blog/705163/202409/705163-20240920102714675-430496611.png)

## 4、自增


**电路**
![image](https://img2024.cnblogs.com/blog/705163/202409/705163-20240923103231832-1029568064.png)

## 5、减法

逻辑表达式：
输出 = NOT(A) AND NOT(B) AND NOT(C) AND NOT(D)

**电路**

![image](https://img2024.cnblogs.com/blog/705163/202409/705163-20240923103402281-879735756.png)

## 6、为0

![image](https://img2024.cnblogs.com/blog/705163/202409/705163-20240923103431706-1032868144.png)

## 7、不为0

![image](https://img2024.cnblogs.com/blog/705163/202409/705163-20240923103458949-1046502080.png)